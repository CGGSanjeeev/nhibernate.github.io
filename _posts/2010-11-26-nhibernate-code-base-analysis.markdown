---
layout: post
title: "NHibernate Code Base Analysis"
date: 2010-11-26 13:40:00 -0300
comments: true
published: true
categories: ["blogs", "nhibernate", "archive"]
tags: ["News", "NHibernate"]
alias: ["/blogs/nhibernate/archive/2010/11/26/nhibernate-code-base-analysis.aspx"]
author: Patrick Smacchia
gravatar: 526161a664210d3946ca432ee787f2af
---
{% include imported_disclaimer.html %}
<p>Patrick Smacchia writing. I am not a NH developer but the creator of a static analysis tool for .NET developer: <a href="http://www.NDepend.com">NDepend</a>. I recently analyzed NH v3.0.0 Candidate Release 1 with NDepend and I had a chance to discuss some results with NH developer Fabio Maulo. Fabio suggested me to show some results on the NH blog, so here it is.</p>
<p>NDepend generated a report by analyzing NH v3.0.0 CR1 code base. See the report <a target="_blank" href="http://www.ndepend.com/SampleReports/OnNHibernate/NDependReport.html">here</a>. NDepend has also the ability to show static analysis results live, inside Visual Studio. The live results are richer than the static report results. Here, I will mostly focus on results extracted from the report, but a few additional results will be obtained from the richer NDepend live capabilities.</p>
<p>&nbsp;</p>
<h4>Code Size<br /></h4>
<p>NH code base weights almost 63K Lines of Code (<a href="http://www.ndepend.com/Metrics.aspx#NbLinesOfCode">LoC</a> as defined here). Developers hates LoC as a productivity yardstick measurement, but it doesn't mean that the LoC code metric is useless. LoC represents a great way to compare code base size and gets an idea of the overall development effort. In the <i>report namespace metrics section</i>, we can see that the namespace <b>NHibernate.Hql.Ast.ANTLR.*</b> generated by ANTLR weights around 18K LoC. So we can consider that NH handcrafted code weights <b>45 LoC</b>. Now we have a number to compare to the <b>19K LoC</b> of NUnit, the <b>28K LoC</b> of CC.NET, the <b>32K LoC</b> of Db4o, the <b>110K LoC</b> of NDepend, the roughly <b>130 KLoC</b> of Llblgen, the roughly <b>500K LoC</b> (or so) of R# (that certainly contains a significant portion of generated code) and the roughly <b>2M LoC </b>of the .NET Fx 4.</p>
<p>So not only NH is one of the most successful OSS initiative, it is also one of the biggest OSS code base. To quote one NH contributor, <i>NH is a big beast</i>!</p>
<p>&nbsp;</p>
<h4>Assembly Partitioning<br /></h4>
<p>NH is packaged in a single <i>NHibernate.dll</i> assembly. I am a big advocate of reducing the number of assemblies and one assembly seems an ideal number. This way:</p>
<ul>
<li>Projects consumers of NH just need to link, maintain the reference to just one assembly. This is a very good thing compared to many other OSS Fx that force to reference, maintain many assemblies.</li>
<li>Compilation time is much (much) faster. Compilation time of one single VS project can be easily 10 times faster than the compilation time of the same code base partitioned in many VS projects.</li>
<li>Startup-time of an application using NH is a bit faster. Indeed, the CLR comes with a slight overhead for each extra assemblies to load at runtime.</li>
</ul>
<p>On the dependency graph or dependency matrix diagrams of the report, I can see that the NH assembly is linking 3 extra assemblies that needs to be redistributed as well: <i>Antlr3.Runtime</i>, <i>Remotion.Data.Linq</i>, and <i>Iesi.Collections</i>.</p>
<p>&nbsp;</p>
<p><b>Code Coverage and NH Code Correctness<br /></b></p>
<p>The report shows the number <b>75.93%</b> code coverage ratio. This is an excellent score, especially taken account the large code size. I consider code coverage ratio as the queen the of the code quality metrics. The higher it is, the less likely it is to release a bug in production. However things are not so simple.&nbsp; High code coverage ratio matters if (<b>and only if)</b> the number of checks performed while running unit tests is also high. These checks are usually done in test code (through API like <b>Assert.IsTrue(...)</b> ). But few developers realize that checks have the same value if they are done in the code tested itself through the API <b>Debug.Assert(...)</b> or through the new <b>Microsoft Code Contract API</b>. The two important things is that checks (or contract if you prefer) must not slow down execution, and must fail abruptly when the condition is violated.</p>
<p>I can quickly see that NH doesn't use Debug.Assert(...) nor the new Microsoft Code Contract API. But on the other hands I can see that NH comes with 2735 unit tests, all successfully executed. This significant number, coupled with the <b>75,93%</b> code coverage ratio, advocate for an excellent testing plan for NH. To quote one NH contributor I talked with once:&nbsp; <i>NH is very hard to break</i>! (but by using code contracts and striving for an even higher code coverage ratio it would be even harder to break).</p>
<p>An another and obvious reason why NH code is rock solid, is related to the huge NH community size, that can be counted in hundred of thousands of developers and projects. In this condition, any bug has very few chances to live for a long time.</p>
<p>&nbsp;</p>
<p><b>Code Architecture</b></p>
<p>Most of .NET developers consider (wrongly IMHO) that .NET code must be componentized through .NET assembly (meaning through VS projects). As discussed above, having very few assemblies comes with important benefits. The essential point is that assemblies are physical artifacts while components are logical artifacts. Hence assembly partitioning must be driven by physical reasons (like lazy-code loading or an addin system).</p>
<p>Nevertheless a 63K LoC code base needs a solid architecture. A solid architecture is the key for high code maintainability. How to define components in .NET code? Personally my preference goes to the usage of namespaces to define component. This way of doing comes wit many advantages: namespaces are logical artifacts, namespaces can be structured hierarchically, architecture explorer tooling can deal out-of-the-box with namespaces, namespaces are supported at language-level and namespaces can be used to draw explicit and concrete boundaries.</p>
<p>In a framework such as NH, namespaces are essentially used to organize the public API. This way of doing is not incompatible with componentizing the code through namespaces. But in the case of NH, the project inherited the API structure of the Hibernate project in the Java sphere. The former Hibernate project doesn't rely on code componentization through namespaces, so NH doesn't as well. And there is no hope for any refactoring : this would result in a fatal tsunami of breaking changes in the NH public API.</p>
<p>So NH code base has no obvious (at least to me) nor explicit componentization. I know there are architecture guidelines that NH contributors must learn, understand and follow, but sitting outside of the project, I cannot easily figure them out.</p>
<p><b><br /></b></p>
<p><b>Code Quality</b></p>
<p>If you look back at the report, you'll see many typical <a href="http://www.ndepend.com/SampleReports/OnNHibernate/NDependReport.html">Code Quality rules</a> violated. As said, I consider Code Coverage ratio as the queen of code quality rules, but that doesn't mean that other code quality metrics don't matter. So I can see through the rule <b style="color: #008000; background-color: #e6ffe6;">Methods&nbsp;too&nbsp;complex&nbsp;-&nbsp;critical&nbsp;(ILCyclomaticComplexity) </b>two dozens of awfully complex methods.&nbsp; Most of them seems to be generated by ANTLR . So there is room here to refine the NDepend Code Query Rule to exclude this generated code, like for example...</p>
<p>
<span style="color: #008000;">//&nbsp;&lt;Name&gt;</span><b style="color:#008000;background-color:#E6FFE6">Methods&nbsp;too&nbsp;complex&nbsp;-&nbsp;critical&nbsp;(ILCyclomaticComplexity)</b><span style="color: #008000;">&lt;/Name&gt;<br /></span><span style="color: #0000ff;">WARN</span>&nbsp;<span style="color: #0000ff;">IF</span>&nbsp;<span style="color: #000064;">Count</span>&nbsp;<span style="color: #000000;">&gt;</span>&nbsp;<b style="color:#000000;background-color:#FFFF99">0</b>&nbsp;<span style="color: #0000ff;">IN</span>&nbsp;<span style="color: #0000ff;">SELECT</span>&nbsp;<span style="color: #0000ff;">METHODS</span><span style="color: #000000;">&nbsp;<br /></span><b><span style="color: #0000ff;">OUT</span>&nbsp;<span style="color: #0000ff;">OF</span>&nbsp;<span style="color: #0000ff;">NAMESPACES</span>&nbsp;<span style="color: #a31515;">"NHibernate.Hql.Ast.ANTLR"</span></b>&nbsp;<span style="color: #0000ff;">WHERE</span><span style="color: #000000;">&nbsp;<br />&nbsp;&nbsp;</span><span style="color: #000064;">ILCyclomaticComplexity</span>&nbsp;<span style="color: #000000;">&gt;</span>&nbsp;<b style="color:#000000;background-color:#FFFF99">40</b>&nbsp;<span style="color: #0000ff;">AND</span><span style="color: #000000;">&nbsp;<br />&nbsp;&nbsp;</span><span style="color: #000064;">ILNestingDepth</span>&nbsp;<span style="color: #000000;">&gt;</span>&nbsp;<b style="color:#000000;background-color:#FFFF99">4</b><span style="color: #000000;">&nbsp;<br />&nbsp;&nbsp;</span><span style="color: #0000ff;">ORDER</span>&nbsp;<span style="color: #0000ff;">BY</span>&nbsp;<span style="color: #000064;">ILCyclomaticComplexity</span>&nbsp;<span style="color: #0000ff;">DESC</span><span style="color: #008000;"><br /></span><span style="color: #008000;"><a href="http://www.NDepend.com/Metrics.aspx#ILNestingDepth" target="_blank"></a></span></p>
<p>...and see than now only 3 handcrafted methods are matched (one of those, <b>NHibernate.Cfg.Configuration.GenerateSchemaUpdateScript(Dialect,DatabaseMetadata)</b> has 49 lines of code, a Cyclomatic Complexity of 25 and is 87% covered by tests).</p>
<p>The rule violated <b style="color: #008000; background-color: #e6ffe6;">Methods&nbsp;with&nbsp;too&nbsp;many&nbsp;parameters&nbsp;-&nbsp;critical&nbsp;(NbParameters)</b> is more a concern since we can see here a redundant code smell of having many constructors with plenty of parameters (up to 22 parameters for the ctor of the class <b>NHibernate.Cfg.Mappings</b>).</p>
<p>The rule violated <b style="color: #008000; background-color: #e6ffe6;">Type&nbsp;should&nbsp;not&nbsp;have&nbsp;too&nbsp;many&nbsp;responsibilities&nbsp;(Efferent&nbsp;Coupling) </b>seems to me another concern. It exhibits several <i>god classes</i>, meaning classes with too many responsibilities. Here NDepend bases its measure on the <i>Efferent Coupling</i> code metric, that represents, the number of other types a type is using. The notion of class responsibility is a bit abstract, it is often translated to the tenet: <i>a class should have only one reason to change</i> which is still abstract in my opinion. Obviously the higher the <i>Efferent Coupling</i>, the more likely a class has too many responsibilities. <i>God classes</i> often result from the lack of refactoring during project evolution, iterations after iterations. The <i>god class</i> represented an initial clear concept that has evolved without appropriate refactoring, and developers got used to live with this code smell. In the context of a public framework such as NH, refactoring a public god class or interface might be not and option if this implies unacceptable API public breaking changes.</p>
<p>The rule violated <b style="color: #008000; background-color: #e6ffe6;">Complex&nbsp;methods&nbsp;should&nbsp;be&nbsp;100%&nbsp;covered&nbsp;by&nbsp;tests</b><span style="color: #008000;"> </span>exhibits a few hundreds of relatively complex methods not thoroughly covered by tests. Here also a lot of these methods belong to <b>NHibernate.Hql.Ast.ANTLR</b> and by filtering them, we still have more than 200 matches. This fact is a concern because having high code coverage ratio is not enough. What is important is to have a lot of methods and classes, 100% covered by tests. Indeed, empirically I noticed that: <i>code that is hard to test is often code that contains subtle and hard to find bugs</i>. Unfortunately, the 10% code hard to test is the code that demands more than 50% of test writing resources.</p>
<p>We could continue to enumerate one by one Code Quality rules violated. The truth is that any sufficiently large code base contains thousands of violation of most basic code quality rules. An important decision must be taken to care for code quality before the code becomes so messy that it discourage developers to work on it (and to be honest, I had feedback from two NH contributors that left the project, partly for that reason). Once again, the NH situation here is more the rule than the exception and I'd say that if you are a real-world developer yourself, there are 9 chances on 10 that you are not satisfied by the code quality of the everyday code base you are working on. The problem when deciding to begin to care for code quality is that tooling like NDepend or FxCop reports literally thousands of flaws. However, a tool like NDepend makes things easier through its support for baseline. Concretely one can decide to continuously compare the code base against, say, the last release, and then fix flaws only on code refactored or added since the baseline. This way the team follow the rule <i>if it's not broken don't fix it</i> and it achieves better and better code quality without significant effort. Concretely a CQL rule that should take account of the baseline can be refactored as easily as:</p>
<p>
<span style="color: #008000;">//&nbsp;&lt;Name&gt;</span><b style="color:#008000;background-color:#E6FFE6">From&nbsp;now,&nbsp;all&nbsp;methods&nbsp;added&nbsp;or&nbsp;refactored&nbsp;should not be too complex</b><span style="color: #008000;">&lt;/Name&gt;<br /></span><span style="color: #0000ff;">WARN</span>&nbsp;<span style="color: #0000ff;">IF</span>&nbsp;<span style="color: #000064;">Count</span>&nbsp;<span style="color: #000000;">&gt;</span>&nbsp;<b style="color:#000000;background-color:#FFFF99">0</b>&nbsp;<span style="color: #0000ff;">IN</span>&nbsp;<span style="color: #0000ff;">SELECT</span>&nbsp;<span style="color: #0000ff;">METHODS</span>&nbsp;<span style="color: #0000ff;">WHERE</span><span style="color: #000000;"><br /><br /></span><b><span style="color: #008000;">//&nbsp;Match&nbsp;methods&nbsp;new&nbsp;or&nbsp;modified&nbsp;since&nbsp;Baseline&nbsp;for&nbsp;Comparison...<br /></span><span style="color: #000000;">&nbsp;&nbsp;</span><span style="color: #000000;">(</span><span style="color: #000064;">WasAdded</span>&nbsp;<span style="color: #0000ff;">OR</span>&nbsp;<span style="color: #000064;">CodeWasChanged</span><span style="color: #000000;">)</span></b>&nbsp;<span style="color: #0000ff;">AND</span><span style="color: #000000;"><br /><br /></span><span style="color: #008000;">//&nbsp;...that&nbsp;are too complex<br /></span><span style="color: #000000;">&nbsp; </span><span style="color: #000064;">CyclomaticComplexity</span> <span style="color: #000000;">&gt;</span> <b style="color:#000000;background-color:#FFFF99">10</b></p>
<p><b style="color:#000000;background-color:#FFFF99"></b><span style="color: #000000;"><br /><br /></span><b>Code Evolution</b></p>
<p>And this was a good transition to the last part I'd like to comment: Code Diff. As said NDepend can compare 2 versions of a code base and in the report we compared NH v3.0.0.CR1 with v2.1.2.GA. The rule <b style="color: #008000; background-color: #e6ffe6;">API&nbsp;Breaking&nbsp;Changes:&nbsp;Types</b> seems to exhibit a few matches:</p>
<p>
<span style="color: #008000;">//&nbsp;&lt;Name&gt;</span><b style="color:#008000;background-color:#E6FFE6">API&nbsp;Breaking&nbsp;Changes:&nbsp;Types</b><span style="color: #008000;">&lt;/Name&gt;<br /></span><span style="color: #0000ff;">WARN</span>&nbsp;<span style="color: #0000ff;">IF</span>&nbsp;<span style="color: #000064;">Count</span>&nbsp;<span style="color: #000000;">&gt;</span>&nbsp;<b style="color:#000000;background-color:#FFFF99">0</b>&nbsp;<span style="color: #0000ff;">IN</span>&nbsp;<span style="color: #0000ff;">SELECT</span>&nbsp;<span style="color: #0000ff;">TYPES</span><span style="color: #000000;"><br /></span><span style="color: #0000ff;">WHERE</span>&nbsp;<span style="color: #000064;">IsPublic</span>&nbsp;<span style="color: #0000ff;">AND</span>&nbsp;<span style="color: #000000;">(</span><span style="color: #000064;">VisibilityWasChanged</span>&nbsp;<span style="color: #0000ff;">OR</span>&nbsp;<span style="color: #000064;">WasRemoved</span><span style="color: #000000;">)</span><span style="color: #000000;"><br /></span></p>
<p>Types like <b>NHibernate.Dialect.SybaseAnywhereDialect</b>, <b>NHibernate.Cache.ISoftLock</b> or <b>NHibernate.Cfg.ConfigurationSchema.ClassCacheUsage</b> were public types that have either be removed, renamed, or set to internal types. Also we can see that some public interfaces such as, <b>NHibernate.Proxy.IProxyFactory</b> or <b>NHibernate.Hql.IQueryTranslator</b> have been changed. This can break client code if these interfaces were meant to be implemented by clients.</p>
<p>In the Code diff report section, the query <b style="color:#008000;background-color:#E6FFE6">Public&nbsp;Types&nbsp;added </b>and also <b style="color:#008000;background-color:#E6FFE6">Namespaces added </b>represent a mean to list new features added to NH v3.</p>
<p>
<span style="color: #008000;">//&nbsp;&lt;Name&gt;</span><b style="color:#008000;background-color:#E6FFE6">Public&nbsp;Types&nbsp;added</b><span style="color: #008000;">&lt;/Name&gt;<br /></span><span style="color: #0000ff;">SELECT</span>&nbsp;<span style="color: #0000ff;">TYPES</span>&nbsp;<span style="color: #0000ff;">WHERE</span>&nbsp;<span style="color: #000064;">WasAdded</span>&nbsp;<span style="color: #0000ff;">AND</span>&nbsp;<span style="color: #000064;">IsPublic</span><span style="color: #008000;"><br /></span></p>
<p>Here, we mostly see the prominent new NH v3 linq capabilities through the numerous <b>NHibernate.Linq.*</b> namespaces added, and we can also focus on the many secondary featurettes like <b>NHibernate.SqlTypes.XmlSqlType</b> or <b>NHibernate.Transaction.AdoNetWithDistributedTransactionFactory</b>.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
