---
layout: post
title: "Mapping Source: How map a class without use nothing"
date: 2008-11-17 00:13:00 +1300
comments: true
published: true
categories: ["blog", "archives"]
tags: ["BuildSessionFactory", "HowTo", "NHibernate", "Mapping source"]
alias: ["/blogs/nhibernate/archive/2008/11/16/mapping-source-how-map-a-class-without-use-nothing.aspx"]
---
<!-- more -->
{% include imported_disclaimer.html %}
<p>I don&rsquo;t know how many times you heard a mad man talking about &ldquo;mapping source&rdquo; in NHibernate&hellip;</p>
<p><strong>Map a class in NH without use XML at all ? </strong>only a crazy man can say that [;)].</p>
<p>As usual an entity implementation:</p>
<pre class="code"><span style="color: blue">public class </span><span style="color: #2b91af">Animal<br /></span>{<br />   <span style="color: blue">public virtual int </span>Id { <span style="color: blue">get</span>; <span style="color: blue">private set</span>; }<br />   <span style="color: blue">public virtual string </span>Description { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }<br />}</pre>
<p>Is a simple class because map something else, and <span style="text-decoration: underline;">begin a new framework, is <strong>not</strong> the target of this post</span>.</p>
<p>Now an empty method, to write an integration test, of a new class inherited from the NHibernate configuration class:</p>
<pre class="code"><span style="color: blue">public class </span><span style="color: #2b91af">Configuration </span>: NHibernate.Cfg.<span style="color: #2b91af">Configuration<br /></span>{<br />   <span style="color: blue">public void </span>Register(<span style="color: #2b91af">Type </span>entity){}<br />}</pre>
<p>The integration test, basically, include the SchemaExport, a CRUD and an HQL; what is interesting here is only the setup of the test:</p>
<pre class="code"><span style="color: blue">protected </span><span style="color: #2b91af">Configuration </span>cfg;<br /><span style="color: blue">protected </span><span style="color: #2b91af">ISessionFactoryImplementor </span>sessions;<br /><br />[<span style="color: #2b91af">TestFixtureSetUp</span>]<br /><span style="color: blue">public void </span>TestFixtureSetUp()<br />{<br />   cfg = <span style="color: blue">new </span><span style="color: #2b91af">Configuration</span>();<br />   cfg.Configure();<br />   cfg.Register(<span style="color: blue">typeof</span>(<span style="color: #2b91af">Animal</span>));<br />   <span style="color: blue">new </span><span style="color: #2b91af">SchemaExport</span>(cfg).Create(<span style="color: blue">false</span>, <span style="color: blue">true</span>);<br />   sessions = (<span style="color: #2b91af">ISessionFactoryImplementor</span>)cfg.BuildSessionFactory();<br />}</pre>
<p>
<a href="http://11011.net/software/vspaste"></a></p>
<p>As you can see is similar to a common setup except for cfg.Register(<span style="color: blue">typeof</span>(<span style="color: #2b91af">Animal</span>)). The others parts of the test are available from the download link.</p>
<p>Now I can start the dance&hellip;</p>
<p>In NHibernate all classes metadata are completely decoupled from XML; this mean that <span style="color: #2b91af">SchemaExport</span>, and everything else in NH, absolutely don&rsquo;t need XML files to be used. What I must do is inject everything after call the method cfg.Configure(). The place where all metadata are available is the namespace NHibernate.Mapping. The holder of metadata is the class <span style="color: #2b91af">Configuration</span> trough the class NHibernate.Cfg.<span style="color: #2b91af">Mappings</span>. The provider of an instance of NHibernate.Cfg.<span style="color: #2b91af">Mappings</span> is the <span style="color: #2b91af">Configuration</span> itself trough the method:</p>
<pre class="code"><span style="color: gray">/// &lt;summary&gt;<br />/// </span><span style="color: green">Create a new </span><span style="color: gray">&lt;see cref="Mappings" /&gt; </span><span style="color: green">to add classes and collection<br /></span><span style="color: gray">/// </span><span style="color: green">mappings to.<br /></span><span style="color: gray">/// &lt;/summary&gt;<br /></span><span style="color: blue">public </span><span style="color: #2b91af">Mappings </span>CreateMappings(Dialect.<span style="color: #2b91af">Dialect </span>dialect)</pre>
<p>
<a href="http://11011.net/software/vspaste"></a></p>
<p>That method stay there from loooong time ago.</p>
<p>As we are doing in NH-Core each &ldquo;<em>binder</em>&rdquo; must use at least two classes (to create new metadata):</p>
<ol>
<li>an instance of NHibernate.Cfg.<span style="color: #2b91af">Mappings</span> </li>
<li>the instance of the configured <span style="color: #2b91af">Dialect</span> </li>
</ol>
<h4>The configuration extension</h4>
<pre class="code"><span style="color: blue">public class </span><span style="color: #2b91af">Configuration </span>: NHibernate.Cfg.<span style="color: #2b91af">Configuration<br /></span>{<br />   <span style="color: blue">public void </span>Register(<span style="color: #2b91af">Type </span>entity)<br />   {<br />       <span style="color: #2b91af">Dialect </span>dialect = <span style="color: #2b91af">Dialect</span>.GetDialect(Properties);<br />       <span style="color: #2b91af">Mappings </span>mappings = CreateMappings(dialect);<br />       SetDefaultMappingsProperties(mappings);<br />       <span style="color: blue">new </span><span style="color: #2b91af">EntityMapper</span>(mappings, dialect).Bind(entity);<br />   }<br /><br />   <span style="color: blue">private static void </span>SetDefaultMappingsProperties(<span style="color: #2b91af">Mappings </span>mappings)<br />   {<br />       mappings.SchemaName = <span style="color: blue">null</span>;<br />       mappings.DefaultCascade = <span style="color: #a31515">"none"</span>;<br />       mappings.DefaultAccess = <span style="color: #a31515">"property"</span>;<br />       mappings.DefaultLazy = <span style="color: blue">true</span>;<br />       mappings.IsAutoImport = <span style="color: blue">true</span>;<br />       mappings.DefaultNamespace = <span style="color: blue">null</span>;<br />       mappings.DefaultAssembly = <span style="color: blue">null</span>;<br />   }<br />}</pre>
<p>For each class, I&rsquo;m going to register, I&rsquo;m getting the configured dialect and a new instance of <span style="color: #2b91af">Mappings</span> class. Then I&rsquo;m setting some default values and at the end I&rsquo;m biding the entity type (<span style="color: #2b91af">EntityMapper</span>(mappings, dialect).Bind(entity)).</p>
<h4>The EntityMapper</h4>
<p>Without boring you, with the full code, the heart is here</p>
<pre class="code"><span style="color: blue">public void </span>Bind(<span style="color: #2b91af">Type </span>entity)<br />{<br />   <span style="color: blue">var </span>rootClass = <span style="color: blue">new </span><span style="color: #2b91af">RootClass</span>();<br />   BindClass(entity, rootClass);<br />}<br /><br /><span style="color: blue">private void </span>BindClass(<span style="color: #2b91af">Type </span>entity, <span style="color: #2b91af">PersistentClass </span>pclass)<br />{<br />   pclass.IsLazy = <span style="color: blue">true</span>;<br />   pclass.EntityName = entity.FullName;<br />   pclass.ClassName = entity.AssemblyQualifiedName;<br />   pclass.ProxyInterfaceName = entity.AssemblyQualifiedName;<br />   <span style="color: blue">string </span>tableName = GetClassTableName(pclass);<br />   <span style="color: #2b91af">Table </span>table = mappings.AddTable(<span style="color: blue">null</span>, <span style="color: blue">null</span>, tableName, <span style="color: blue">null</span>, pclass.IsAbstract.GetValueOrDefault());<br />   ((<span style="color: #2b91af">ITableOwner</span>) pclass).Table = table;<br />   pclass.IsMutable = <span style="color: blue">true</span>;<br />   <span style="color: #2b91af">PropertyInfo</span>[] propInfos = entity.GetProperties();<br /><br />   <span style="color: #2b91af">PropertyInfo </span>toExclude = <span style="color: blue">new </span><span style="color: #2b91af">IdBinder</span>(<span style="color: blue">this</span>, propInfos).Bind(pclass, table);<br /><br />   pclass.CreatePrimaryKey(dialect);<br />   BindProperties(pclass, propInfos.Where(x =&gt; x != toExclude));<br />   mappings.AddClass(pclass);<br /><br />   <span style="color: blue">string </span>qualifiedName = pclass.MappedClass == <span style="color: blue">null </span>? pclass.EntityName : pclass.MappedClass.AssemblyQualifiedName;<br />   mappings.AddImport(qualifiedName, pclass.EntityName);<br />   <span style="color: blue">if </span>(mappings.IsAutoImport &amp;&amp; pclass.EntityName.IndexOf(<span style="color: #a31515">'.'</span>) &gt; 0)<br />   {<br />       mappings.AddImport(qualifiedName, <span style="color: #2b91af">StringHelper</span>.Unqualify(pclass.EntityName));<br />   }<br />}</pre>
<p>Including everything the <em>EntityMapper.cs</em> have 198 lines.</p>
<p>Metadata classes used are: <span style="color: #2b91af">RootClass</span>, <span style="color: #2b91af">PersistentClass</span>, <span style="color: #2b91af">Table</span>, <span style="color: #2b91af">SimpleValue</span>, <span style="color: #2b91af">Property</span> and <span style="color: #2b91af">Column</span>.</p>
<h4>Conclusions</h4>
<p>To use NHibernate without write a single XML mapping, <strong>is possible</strong>. Create mapped classes or others artifacts (as typedef, database-objects, named-queries, stored-procedures, filters and so on) without use XML, <strong>is possible</strong>. Because I&rsquo;m extending the NHibernate.Cfg.<span style="color: #2b91af">Configuration</span>, add some other artifacts or override mapping written using XML <strong>is possible</strong>. Write a &ldquo;bridge&rdquo; using EntityFramework attributes instead XMLs, <strong>is possible</strong>.</p>
<p>Write a new framework <strong>avoiding</strong> <strong>XML</strong> at all, <strong>is possible <span style="text-decoration: underline;">that is completely different than &ldquo;is easy&rdquo;</span></strong>. In general a framework is to make something easy to the framework users and not to the framework developers; no?</p>
<p>Code available <a href="http://code.google.com/p/unhaddins/source/browse/#svn/HunabKu/src/MappingSource/MappingSource">here</a>.</p>
